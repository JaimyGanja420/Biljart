<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Tryout Project</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				width: 100%;
				height: 100%;
			}
		</style>
	</head>
	<body>


		<script src="js/three.min.js"></script>
		<script src="js/Physics.js"></script>
		<script src="js/ball.js"></script>
        <script src="js/OrbitControls.js"></script>

		<script>

			//Scene setup
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setClearColor(0x000000);
			document.body.appendChild(renderer.domElement);

			//Camera positioning
			camera.position.z = 20;
			camera.position.y = 20;

			//Orbit controls
			var controls = new THREE.OrbitControls(camera);
			controls.addEventListener('change');

			//Objects
            var loader = new THREE.ObjectLoader();
            loader.load('models/scene.json', function(tafel){
                scene.add(tafel);
            });

			var groundMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff } );
			var ground = new THREE.Mesh( new THREE.PlaneBufferGeometry(100,100,2,2), groundMaterial);
			ground.position.y = -2;
			ground.rotation.x = - Math.PI / 2;
			scene.add(ground);

			scene.add( new THREE.AmbientLight(0x111111));

			var whiteBall = whiteSphere;
            whiteBall.position.y = 0.5;
			whiteBall.speedX = 0.5;
			whiteBall.speedZ = 0.5;
			scene.add(whiteBall);

            var redBall1 = redSphere;
            redBall1.position.y = 0.5;
            redBall1.position.x = 1.5;
			redBall1.speedX = 0.7;
			redBall1.speedZ = 0.5;
            scene.add(redBall1);

			var redBall2 = redBall1.clone();
			redBall2.position.y = 0.5;
			redBall2.position.x = 3;
			redBall2.speedX = 0.5;
			redBall2.speedZ = 0.7;
			scene.add(redBall2);

			//keu
			var isRemoved = false;
			var keuGeometry = new THREE.BoxGeometry(1,1,1);
			var keuMaterial = new THREE.MeshBasicMaterial( {color: 0xffff00 } );
			var keu = new THREE.Mesh( keuGeometry, keuMaterial );

			keu.position.x = whiteBall.position.x + 1;
			keu.position.y = 0.5;
			keu.position.z = whiteBall.position.z;
			scene.add(keu);

			//rotation variables
			const distance = 1;
			const speed = 0.1;
			var counter = 0;

			//key handlers
			var isRightPressed = false;
			var isLeftPressed = false;
			var isShoot = false;
			document.addEventListener("keydown", handleKeyDown, false);
			document.addEventListener("keyup", handleKeyUp, false);

			function handleKeyDown(e)
			{
				if(e.keyCode == 65)
				{
					isRightPressed = true;
				} else if(e.keyCode == 68)
				{
					isLeftPressed = true;
				}
				else if(e.keyCode == 86)
				{
					isShoot = true;
				}
			}

			function handleKeyUp(e)
			{
				if(e.keyCode == 65)
				{
					isRightPressed = false;
				} else if(e.keyCode == 68)
				{
					isLeftPressed = false;
				}
			}

			//shoot function
			function shoot()
			{
				whiteBall.speedX = (keu.position.x - whiteBall.position.x) * -1;
				whiteBall.speedZ = (keu.position.z - whiteBall.position.z) * -1;
				console.log(whiteBall.speedX);
				console.log(whiteBall.speedZ);
				isShoot = false;
			}

			//keu rotation function
			function rotateKeu()
			{
				if(whiteBall.speedX == 0 && whiteBall.speedZ == 0)
				{
					if(isRemoved)
					{
						scene.add(keu);
						keu.position.x = whiteBall.position.x + distance * Math.sin(counter);
						keu.position.z = whiteBall.position.z + distance * Math.cos(counter);
						isRemoved = false;
					}
					if(isRightPressed)
					{
						counter -= speed;
						keu.position.x = whiteBall.position.x + distance * Math.sin(counter);
						keu.position.z = whiteBall.position.z + distance * Math.cos(counter);
					} else if(isLeftPressed)
					{
						counter += speed;
						keu.position.x = whiteBall.position.x + distance * Math.sin(counter);
						keu.position.z = whiteBall.position.z + distance * Math.cos(counter);
					}
				}else
				{
					console.log(whiteBall.speedX);
					console.log(whiteBall.speedZ);
					if(!isRemoved)
					{
						scene.remove(keu);
						isRemoved = true;
					}
				}
			}

			//Renderer
			function render() {
			    //Render init
				requestAnimationFrame(render);
				renderer.render(scene, camera);

				//Ball speed vectors
				whiteBall.position.x += whiteBall.speedX;
				whiteBall.position.z += whiteBall.speedZ;

				redBall1.position.x += redBall1.speedX;
				redBall1.position.z += redBall1.speedZ;

				redBall2.position.x += redBall2.speedX;
				redBall2.position.z += redBall2.speedZ;

				//Physics functions
				for(var index = 0; index < ballgroup.length; index++) {
					slowDown(ballgroup[index]);
					collideWall(ballgroup[index]);
				}


				if(isShoot)
				{
					shoot();
				}

				rotateKeu();
				/*for(var i = 0; i < boxgroup.length; i++){
					for(var x = 0; x < boxgroup.length; x++){
						if(i != x)
							collide(boxgroup[i], boxgroup[x], ballgroup[i], ballgroup[x]);
					}
				}*/

				/*if (whitebox.box.isIntersectionBox(redbox1.box)){
					//Speed transfer
					tempx = whiteBall.SpeedX;
					whiteBall.SpeedX = redBall1.SpeedX;
					redBall1.SpeedX = tempx;

					tempz = whiteBall.SpeedZ;
					whiteBall.SpeedZ = redBall1.SpeedZ;
					redBall1.SpeedZ = tempz;
				}*/

                whiteBox.update();
                redBox.update();

			}
			render();
		</script>
	</body>
</html>


