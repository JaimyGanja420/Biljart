<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Tryout Project</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				width: 100%;
				height: 100%;
				margin: 0px;
			}
		</style>
	</head>
	<body>


		<script src="js/three.min.js"></script>
		<script src="js/ball.js"></script>
		<script src="js/SpotLight.js"></script>
		<script src="js/FirstPersonControls.js"></script>

		<script>
			var scene = new THREE.Scene();
			
			var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setClearColor(0x000000);
			document.body.appendChild(renderer.domElement);

			var bGeometry = new THREE.SphereGeometry(0.5,16,8);
			var cGeometry = new THREE.BoxGeometry(1,1,1);
			//var cMaterial = new THREE.MeshBasicMaterial( { color:0xff0040 } );
			//var cMaterial = new THREE.MeshPhongMaterial( { color:0xff0040 } );
			var cMaterial = new THREE.MeshPhongMaterial( { color:0xf0f0f0 } );
			var ball = new THREE.Mesh(bGeometry,cMaterial);
			//var cube = new Ball();

			var keu = new THREE.Mesh(cGeometry,cMaterial);

			ball.position.z = -15;


			scene.add(keu);


			var clonedBall = ball.clone();
			clonedBall.position.z = -15;
			clonedBall.position.x = -5;
			
			var cGroup = new THREE.Group();
			var ballGroup = new THREE.Group();

			ballGroup.add(ball);
			ballGroup.add(clonedBall);

			scene.add(cGroup);
			scene.add(ballGroup);

			var lGeometry = new THREE.BoxGeometry(1,1,10);
			var l2Geometry = new THREE.BoxGeometry(31,1,1);
			//var lMaterial = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
			var lMaterial = new THREE.MeshPhongMaterial( { color: 0x00ff00 } );
			var longCube = new THREE.Mesh(lGeometry,lMaterial);
			var l2Cube = new THREE.Mesh(l2Geometry,lMaterial);

			l2Cube.position.z = -9.5;
			l2Cube.position.x = 0;

			longCube.position.z = -15;
			longCube.position.x = -15;

			cGroup.add(longCube);
			
			var clonedLongCube = longCube.clone();
			clonedLongCube.position.x = 15;

			var clonedL2Cube = l2Cube.clone();
			clonedL2Cube.position.z = -20.5;

			cGroup.add(clonedLongCube);
			cGroup.add(l2Cube);
			cGroup.add(clonedL2Cube);
			
			//var groundMaterial = new THREE.MeshBasicMaterial( { color: 0xf0f0f0 } );
			var groundMaterial = new THREE.MeshPhongMaterial( { color: 0xf0f0f0 } );
			
			var ground = new THREE.Mesh( new THREE.PlaneBufferGeometry(100,100,2,2), groundMaterial);
			ground.position.y = -2;
			ground.rotation.x = - Math.PI / 2;
			scene.add(ground);
			
			var raycaster = new THREE.Raycaster();
			
			var cubeDirection = new THREE.Vector3();
			cubeDirection.x = -1;
			cubeDirection.z = -1;
			cubeDirection.normalize();
			
			var speed = new THREE.Vector3();
			var ballSpeed = 0;
			
			//var blueMaterial = new THREE.MeshBasicMaterial( { color: 0x0040ff } );
			var blueMaterial = new THREE.MeshPhongMaterial( { color: 0x0040ff } );
			//var greenMaterial = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
			var greenMaterial = new THREE.MeshPhongMaterial( { color: 0x00ff00 } );

			
			//scene.add(new THREE.AmbientLight(0xf0f0f0));
			scene.add( new THREE.AmbientLight(0x111111));
			
			var sphere = new THREE.SphereGeometry(0.5, 16, 8);
			
			var light1 = new THREE.PointLight(0xff0040, 1.5, 100);
			light1.add(new THREE.Mesh(sphere, new THREE.MeshBasicMaterial( { color: 0xff0040 } )));
			light1.position.set(0, 4, -15);
			scene.add(light1);
			
			var light2 = new THREE.PointLight(0xf0f0f0, 0.5, 100);
			light2.add(new THREE.Mesh(sphere, new THREE.MeshBasicMaterial( { color: 0xf0f0f0 } )));
			light2.position.set(-15, 4, -15);
			scene.add(light2);
			
			var light3 = new THREE.PointLight(0xf0f0f0, 0.5, 100);
			light3.add(new THREE.Mesh(sphere, new THREE.MeshBasicMaterial( { color: 0xf0f0f0 } )));
			light3.position.set(15, 4, -15);
			scene.add(light3);

			function collide(){
				if(ball.x + ball.radius + clonedBall.radius > clonedBall.x
				&& ball.x < clonedBall.x + ball.radius + clonedBall.radius
				&& ball.z + ball.radius + clonedBall.radius > clonedBall.z
				&& ball.z < clonedBall.y + ball.radius + clonedBall.radius)
				{
					var distance = Math.sqrt(
							((ball.x - clonedBall.x) * (ball.x - clonedBall.x))
							+ ((ball.z - clonedBall.z) * (ball.z - clonedBall.z))
					);
					if(distance < ball.radius + clonedBall.radius){
						ballspeed = 0;
					}
				}
			}

			function render() {
				requestAnimationFrame(render);

				
				ball.position.add(speed.copy(cubeDirection).multiplyScalar(ballSpeed));
				
				raycaster.set(ball.position, cubeDirection);
				
				var intersections = raycaster.intersectObjects(cGroup.children);
				
				if(intersections.length > 0) {
					var intersection = intersections[0];
					
					if(intersection.distance < 2) {
						cubeDirection.reflect(intersection.face.normal);
					}
				}

				keu.position.z = ball.position.z + 1;
				
				
				for (var name in cGroup.children) {
					var currentElement = cGroup.children[name];
					currentElement.material = blueMaterial;
				}

				raycaster.setFromCamera(mouse, camera);
				
				var mouseIntersections = raycaster.intersectObjects(cGroup.children);
				
				if (mouseIntersections.length > 0) {
					var intersection = mouseIntersections[0];
					
					intersection.object.material = greenMaterial;
				}
				if(ballSpeed > 0)
					ballSpeed -= 0.001;

				renderer.render(scene,camera);
			}
			
			var mouse = new THREE.Vector2();
			
			document.addEventListener('mousemove', onDocumentMouseMove, false);
			document.addEventListener('mousedown', onDocumentMouseDown, false);
			
			function onDocumentMouseMove(event) {
				
				event.preventDefault();
				
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
			}
			
			camera.position.y = 10;
			camera.lookAt(ball.position);

			function onDocumentMouseDown(event){
				event.preventDefault();

				mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

				raycaster.setFromCamera(mouse, camera);

				var intersects = raycaster.intersectObject(ball);
				if(intersects.length > 0) {
					ballSpeed = 0.5;
				}
			}

			var angle = 1;

			document.body.onkeyup = function(e){
				if(e.keyCode == 32)
				{
					var directionX = 0;
					var directionZ = 0;
					if(angle <= 180)
					{
						directionX = 1 - 1 / 180 * angle;
						directionZ = 1 - 1 / 180 * angle;
					}else
					{
						directionX = -1 + 1 / 360 * angle;
						directionZ = -1 + 1 / 360 * angle;
					}
					cubeDirection.x = directionX;
					cubeDirection.z = directionZ;
					ballSpeed = 0.5;
				}else if(e.keyCode == 37)
				{
					if(angle < 360)
					{
						angle += 1;
					}else
					{
						angle = 1;
					}
				}else if(e.keyCode == 39)
				{
					if(angle > 1)
					{
						angle -= 1;
					}else
					{
						angle = 360;
					}
				}
			}

			
			render();
		</script>
	</body>
</html>
